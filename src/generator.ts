import { WasmModuleInfo, WasmValueType } from './types';
import * as path from 'path';
import * as fs from 'fs-extra';

function mapToTS(t: WasmValueType): string {
    switch (t) {
        case 'i32':
        case 'f32':
        case 'f64':
            return 'number';
        case 'i64':
            return 'bigint';
        default:
            return 'any';
    }
}

// Detect if a function looks like (ptr: i32, len: i32) â†’ void
function isStringFunction(f: {
    params: WasmValueType[];
    results: WasmValueType[];
}) {
    return (
        f.params.length === 2 && f.params[0] === 'i32' && f.params[1] === 'i32'
    );
}

function capitalize(s: string) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

export async function generateBindings(
    moduleInfo: WasmModuleInfo,
    wasmFilePath: string,
    outDir: string,
    moduleName: string,
    options: { noTypes?: boolean; noWrapper?: boolean } = {},
) {
    await fs.ensureDir(outDir);

    // --- .d.ts ---
    const dts = `// Auto-generated by wasm-types
        declare module "./${moduleName}.wasm" {
          export interface Exports {
        ${moduleInfo.exports
            .map(
                (f) =>
                    `    ${f.name}(${f.type.params
                        .map((p, i) => `arg${i}: ${mapToTS(p)}`)
                        .join(', ')}): ${
                        f.type.results.length > 0
                            ? mapToTS(f.type.results[0])
                            : 'void'
                    };`,
            )
            .join('\n')}
        ${moduleInfo.hasMemory ? '    memory: WebAssembly.Memory;' : ''}
          }
          const init: (imports?: WebAssembly.Imports) => Promise<Exports>;
          export default init;
        }
`;
    await fs.writeFile(path.join(outDir, `${moduleName}.wasm.d.ts`), dts);

    // --- .js wrapper ---
    if (!options.noWrapper) {
        const stringInputHelpers = moduleInfo.exports
            .filter((f) => isStringFunction(f.type))
            .map(
                (f) => `
                    function ${f.name}String(str) {
                        const ptr = encodeString(str, exports.memory, exports.alloc);
                        exports.${f.name}(ptr, str.length);
                    }
                `,
            )
            .join('\n');

        const stringReturnHelpers = moduleInfo.exports
            .filter((f) => isStringFunction(f.type))
            .map(
                (f) => `
                    function get${capitalize(f.name)}String(...args){
                        const [ptr, len] = exports.${f.name}(...args);
                        return decodeString(ptr, len, exports.memory);
                    }
                `,
            );

        const js = `// Auto-generated by wasmforge
            import { encodeString, decodeString } from "./wasmforge-runtime.js";

            export default async function init(imports = {}) {
            const response = await fetch("./${moduleName}.wasm");
            const { instance } = await WebAssembly.instantiateStreaming(response, imports);
            const exports = instance.exports;

            ${stringInputHelpers}
            ${stringReturnHelpers}

            return {
                ...exports,
                rawExports: exports,
                memory: exports.memory,
        ${moduleInfo.exports
            .filter((f) => isStringFunction(f.type))
            .map((f) => `    ${f.name}String,`)
            .join('\n')}
            ${moduleInfo.exports
                .filter((f) => isStringFunction(f.type))
                .map((f) => `    get${capitalize(f.name)}String,`)
                .join('\n')}
            };
            }
        `;
        await fs.writeFile(path.join(outDir, `${moduleName}.wasm.js`), js);
    }
}
