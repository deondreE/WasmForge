import { WasmModuleInfo, WasmValueType } from './types';
import * as path from 'path';
import * as fs from 'fs-extra';

function mapToTS(t: WasmValueType): string {
    switch (t) {
        case 'i32':
        case 'f32':
        case 'f64':
            return 'number';
        case 'i64':
            return 'bigint';
        default:
            return 'any';
    }
}

export async function generateBindings(
    moduleInfo: WasmModuleInfo,
    wasmFilePath: string,
    outDir: string,
    moduleName: string,
) {
    await fs.ensureDir(outDir);

    // --- .d.ts ---
    const dts = `// Auto-generated by wasm-types
declare module "./${moduleName}.wasm" {
  export interface Exports {
${moduleInfo.exports
    .map(
        (f) =>
            `    ${f.name}(${f.type.params
                .map((p, i) => `arg${i}: ${mapToTS(p)}`)
                .join(', ')}): ${
                f.type.results.length > 0 ? mapToTS(f.type.results[0]) : 'void'
            };`,
    )
    .join('\n')}
${moduleInfo.hasMemory ? '    memory: WebAssembly.Memory;' : ''}
  }
  const init: (imports?: WebAssembly.Imports) => Promise<Exports>;
  export default init;
}
`;
    await fs.writeFile(path.join(outDir, `${moduleName}.wasm.d.ts`), dts);

    // --- .js wrapper ---
    const js = `// Auto-generated by wasm-types
export default async function init(imports = {}) {
  const response = await fetch("./${moduleName}.wasm");
  const { instance } = await WebAssembly.instantiateStreaming(response, imports);
  return instance.exports;
}
`;
    await fs.writeFile(path.join(outDir, `${moduleName}.wasm.js`), js);
}
